# This workflow uses actions that are not certified by GitHub.
# They are provided by a third-party and are governed by
# separate terms of service, privacy policy, and support
# documentation.

name: trivy

# on:
#   push:
#     branches: [ "main" ]
#   pull_request:
#     # The branches below must be a subset of the branches above
#     branches: [ "main" ]
#   schedule:
#     - cron: '24 16 * * 0'

# permissions:
#   contents: read

on:
  # Manual trigger only from any branch
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to run Trivy on'
        required: false
        default: 'main'
      build_flavor:
        description: 'Build flavor for tagging'
        required: false
        default: 'non_prod'
        type: choice
        options:
        - non_prod
        - prod

  # Allow this workflow to be called by other workflows
  workflow_call:
    inputs:
      branch:
        description: 'Branch to run Trivy on'
        required: false
        default: 'main'
        type: string
      build_flavor:
        description: 'Build flavor for tagging'
        required: false
        default: 'non_prod'
        type: string

jobs:
  build:
    permissions:
      contents: read # for actions/checkout to fetch code
      security-events: write # for github/codeql-action/upload-sarif to upload SARIF results
      actions: read # only required for a private repository by github/codeql-action/upload-sarif to get the Action run status
    name: Build and Scan Docker Images
    runs-on: [self-hosted, linux, X64]
    outputs:
      vulnerability_found: ${{ steps.scan_summary.outputs.vulnerability_found }}
      images_scanned: ${{ steps.scan_summary.outputs.images_scanned }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          ref: ${{ github.event.inputs.branch || github.ref }}

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Azure Container Registry
        uses: azure/docker-login@v1
        with:
          login-server: ispirt.azurecr.io
          username: ${{ secrets.AZURE_REGISTRY_USERNAME }}
          password: ${{ secrets.AZURE_REGISTRY_PASSWORD }}

      - name: Build the code
        run: |
          echo "Building code with the specified parameters and Azure Blob cache..."
          echo "Current directory: $(pwd)"
          echo "Workspace: ${GITHUB_WORKSPACE}"
          
          # Ensure we're in the correct workspace directory
          cd "${GITHUB_WORKSPACE}"
          
          # Make the script executable
          chmod +x ./production/packaging/build_and_test_all_in_docker
          
          # Show the bazel config for debugging
          echo "Current .bazelrc content:"
          cat .bazelrc | tail -10
          
          # Set explicit environment variables to control container behavior and prevent breakout
          export WORKSPACE="${GITHUB_WORKSPACE}"
          export WORKSPACE_MOUNT="${GITHUB_WORKSPACE}"
          export DOCKER_BUILDKIT=1
          
          # Ensure no conflicting containers exist
          docker stop $(docker ps -aq --filter "name=cbuild-*") 2>/dev/null || true
          docker rm $(docker ps -aq --filter "name=cbuild-*") 2>/dev/null || true
          
          # Run the build with explicit workspace context
          ./production/packaging/build_and_test_all_in_docker \
            --service-path bidding_service \
            --service-path buyer_frontend_service \
            --no-precommit \
            --no-tests \
            --build-flavor ${{ github.event.inputs.build_flavor || 'non_prod' }} \
            --platform azure \
            --instance local

      - name: List generated artifacts
        run: |
          echo "Generated tar files for Docker loading:"
          find . -name "*.tar" -type f | head -10
          echo "Generated artifacts in dist/:"
          ls -la dist/ 2>/dev/null || echo "No dist/ directory found"
          echo "Generated artifacts in dist/azure/:"
          ls -la dist/azure/ 2>/dev/null || echo "No dist/azure/ directory found"

      - name: Check for Docker tar files in dist/azure
        id: check_files
        run: |
          echo "Checking for Docker tar files in dist/azure directory..."
          if [ ! -d "dist/azure" ]; then
            echo "‚ùå dist/azure directory not found"
            echo "tar_files_found=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Find all tar files in dist/azure
          TAR_FILES=$(find dist/azure -name "*.tar" -type f)
          if [ -z "$TAR_FILES" ]; then
            echo "‚ùå No tar files found in dist/azure"
            echo "tar_files_found=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          echo "‚úÖ Found tar files:"
          echo "$TAR_FILES"
          echo "tar_files_found=true" >> $GITHUB_OUTPUT
          
          # Save tar files list for next steps
          echo "$TAR_FILES" > tar_files_list.txt

      - name: Load and scan Docker images
        id: scan_images
        run: |
          VULNERABILITY_FOUND=false
          IMAGES_SCANNED=0
          SCAN_RESULTS=""
          
          echo "üîç Starting Docker image scanning process..."
          
          while IFS= read -r tar_file; do
            if [ -z "$tar_file" ]; then continue; fi
            
            echo "üì¶ Processing: $tar_file"
            
            # Load the Docker image from tar file
            echo "Loading Docker image from tar file..."
            LOADED_OUTPUT=$(docker load -i "$tar_file")
            echo "$LOADED_OUTPUT"
            
            # Extract image name from docker load output
            IMAGE_NAME=$(echo "$LOADED_OUTPUT" | grep "Loaded image:" | cut -d' ' -f3)
            if [ -z "$IMAGE_NAME" ]; then
              echo "‚ùå Failed to extract image name from: $tar_file"
              continue
            fi
            
            echo "‚úÖ Loaded image: $IMAGE_NAME"
            IMAGES_SCANNED=$((IMAGES_SCANNED + 1))
            
            # Create unique output file for this image
            SERVICE_NAME=$(basename "$tar_file" .tar | sed 's/_image$//')
            SARIF_OUTPUT="trivy-results-${SERVICE_NAME}.sarif"
            
            echo "üîç Running Trivy scan on: $IMAGE_NAME"
            
            # Run Trivy scan in SARIF format only
            docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
              -v $(pwd):/workspace \
              aquasec/trivy:latest image \
              --format sarif \
              --output "/workspace/$SARIF_OUTPUT" \
              --severity CRITICAL,HIGH,MEDIUM \
              "$IMAGE_NAME"
            
            # Check if vulnerabilities were found by examining scan exit code
            if docker run --rm -v /var/run/docker.sock:/var/run/docker.sock \
              aquasec/trivy:latest image \
              --format table \
              --severity CRITICAL,HIGH \
              --exit-code 1 \
              "$IMAGE_NAME" > /dev/null 2>&1; then
              echo "‚úÖ No critical/high vulnerabilities found in $SERVICE_NAME"
              SCAN_RESULTS="${SCAN_RESULTS}‚úÖ $SERVICE_NAME: No critical/high vulnerabilities found\n"
            else
              echo "‚ùå Critical/high vulnerabilities found in $SERVICE_NAME"
              VULNERABILITY_FOUND=true
              SCAN_RESULTS="${SCAN_RESULTS}‚ùå $SERVICE_NAME: Critical/high vulnerabilities found\n"
            fi
            
          done < tar_files_list.txt
          
          echo "vulnerability_found=$VULNERABILITY_FOUND" >> $GITHUB_OUTPUT
          echo "images_scanned=$IMAGES_SCANNED" >> $GITHUB_OUTPUT
          echo "scan_results<<EOF" >> $GITHUB_OUTPUT
          echo -e "$SCAN_RESULTS" >> $GITHUB_OUTPUT
          echo "EOF" >> $GITHUB_OUTPUT
          
          echo "üìã Scan Summary:"
          echo "Images scanned: $IMAGES_SCANNED"
          echo "Vulnerabilities found: $VULNERABILITY_FOUND"
          echo -e "$SCAN_RESULTS"

      - name: Upload Trivy SARIF results
        uses: actions/upload-artifact@v4
        with:
          name: trivy-sarif-results
          path: trivy-results-*.sarif

      # Alternative method using GitHub Actions for SARIF upload
      - name: Upload individual SARIF files using GitHub Action
        if: always()
        run: |
          # Create individual upload jobs for each SARIF file
          for sarif_file in trivy-results-*.sarif; do
            if [ -f "$sarif_file" ]; then
              echo "Found SARIF file: $sarif_file"
            fi
          done
        
      # Upload each SARIF file individually
      - name: Upload bidding service SARIF
        if: always() && hashFiles('trivy-results-bidding_service.sarif') != ''
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results-bidding_service.sarif'
          category: 'trivy-bidding-service'
        continue-on-error: true

      - name: Upload buyer frontend service SARIF  
        if: always() && hashFiles('trivy-results-buyer_frontend_service.sarif') != ''
        uses: github/codeql-action/upload-sarif@v3
        with:
          sarif_file: 'trivy-results-buyer_frontend_service.sarif'
          category: 'trivy-buyer-frontend-service'
        continue-on-error: true



      - name: Generate security report
        id: scan_summary
        if: always()
        run: |
          echo "# Docker Security Scan Report" > security_report.md
          echo "**Date:** $(date)" >> security_report.md
          echo "**Branch:** ${{ github.event.inputs.branch || github.ref_name }}" >> security_report.md
          echo "**Build Flavor:** ${{ github.event.inputs.build_flavor || 'non_prod' }}" >> security_report.md
          echo "" >> security_report.md
          echo "## Scan Results" >> security_report.md
          echo "Images scanned: ${{ steps.scan_images.outputs.images_scanned }}" >> security_report.md
          echo "Vulnerabilities found: ${{ steps.scan_images.outputs.vulnerability_found }}" >> security_report.md
          echo "" >> security_report.md
          echo "### Detailed Results" >> security_report.md
          echo -e "${{ steps.scan_images.outputs.scan_results }}" >> security_report.md
          
          if [ "${{ steps.scan_images.outputs.vulnerability_found }}" = "true" ]; then
            echo "" >> security_report.md
            echo "## ‚ö†Ô∏è Action Required" >> security_report.md
            echo "Critical or high vulnerabilities were found. Please review the SARIF files and address the vulnerabilities." >> security_report.md
          else
            echo "" >> security_report.md
            echo "## ‚úÖ Security Status" >> security_report.md
            echo "No critical or high vulnerabilities found. Images passed security scan." >> security_report.md
          fi
          
          cat security_report.md
          
          # Set outputs for other jobs
          echo "vulnerability_found=${{ steps.scan_images.outputs.vulnerability_found }}" >> $GITHUB_OUTPUT
          echo "images_scanned=${{ steps.scan_images.outputs.images_scanned }}" >> $GITHUB_OUTPUT

      - name: Upload security report
        uses: actions/upload-artifact@v4
        with:
          name: docker-security-report
          path: security_report.md

      - name: Cleanup build artifacts
        if: always()
        run: |
          echo "Cleaning up build artifacts..."
          # Clean up any docker artifacts that might have permission issues
          docker container prune -f || true
          
          # Fix permissions on workspace files, subsequent runs fail,
          # because of some files with root permissions
          sudo chown -R $(whoami):$(whoami) ${GITHUB_WORKSPACE} || true
          
          echo "Cleanup completed for ${{ matrix.language }}"
          
          # Clean up any temporary mounts
          sudo umount /tmp/* 2>/dev/null || true
      